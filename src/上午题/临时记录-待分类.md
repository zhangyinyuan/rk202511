# 临时记录-待分类

## 函数依赖的Armstrong 公理系统（Armstrong's Axioms）

### ① 三条基本公理 (谐音记忆： 自增传Zhuan)

1. **自反律（Reflexivity）**
    如果 $Y \subseteq X$，则 $X \to Y$
    👉 任何属性集函数决定它的子集。
    例：如果 $X = {A, B}$，则 ${A, B} \to {A}$。
2. **增广律（Augmentation）**
    如果 $X \to Y$，则 $XZ \to YZ$
    👉 在依赖两边同时加相同的属性，依赖仍然成立。
    例：如果 $A \to B$，则 $AC \to BC$。
3. **传递律（Transitivity）**
    如果 $X \to Y$，且 $Y \to Z$，则 $X \to Z$
    👉 依赖可以传递。
    例：$A \to B, B \to C \implies A \to C$。

------

### ② 常用推论（由三条基本公理导出）

1. **合并律（Union / Composition）**
    如果 $X \to Y$ 且 $X \to Z$，则 $X \to YZ$
2. **分解律（Decomposition / Projectivity）**
    如果 $X \to YZ$，则 $X \to Y$ 且 $X \to Z$
3. **伪传递律（Pseudo-Transitivity）**
    如果 $X \to Y$ 且 $WY \to Z$，则 $WX \to Z$

------

### ③ 用途

- 判断一个函数依赖是否能由已知依赖推出。
- 计算属性闭包（Closure）。
- 判断候选键、超键。
- 数据库规范化（2NF、3NF、BCNF）。

------

### 📖 总结口诀

- **自反律**：大包小必然成立。
- **增广律**：左右同加仍然真。
- **传递律**：$X \to Y, Y \to Z \Rightarrow X \to Z$。
- **合并律**：依赖可以并到一起。
- **分解律**：依赖可以拆开单个。
- **伪传递律**：加个 $W$ 也能传。

---

## 软件维护的四种类型

1. **改正性维护（Corrective Maintenance）**
   - 修复软件在运行中发现的错误或缺陷。
   - 关键词：**纠错、修复缺陷**。
2. **适应性维护（Adaptive Maintenance）** ✅
   - 当**运行环境发生变化**（软硬件、操作系统、数据库版本等），为了保证软件继续运行而进行的修改。
   - 关键词：**适应环境变化**。
3. **完善性维护（Perfective / Improvement Maintenance）**
   - 在用户需求变化时，为了**改进性能或增强功能**而进行的修改。
   - 关键词：**增强功能、改善性能**。
4. **预防性维护（Preventive Maintenance）**
   - 为了**提高软件可维护性、预防未来潜在问题**，提前修改软件。
   - 关键词：**未雨绸缪、提高可靠性**。

### 📌 总结口诀

- **改正性：修 bug**
- **适应性：换环境**
- **完善性：加功能/优化提升性能**
- **预防性：防未来**

----

## 网络分层模型与设备对应

### ① 五层协议模型

1. **应用层**
   - 协议：HTTP、FTP、SMTP、DNS
   - 设备：应用软件
2. **传输层**
   - 协议：TCP、UDP
   - 设备：防火墙（**部分功能涉及传输层**端口控制）
3. **网络层**
   - 协议：IP、ICMP、ARP、RIP、OSPF
   - 设备：**路由器、防火墙（主要功能）**
4. **数据链路层**
   - 协议：以太网（Ethernet）、PPP、HDLC
   - 设备：**交换机、网桥**
5. **物理层**
   - 信号传输，比特流
   - 设备：**中继器、集线器、网线、光纤、网卡（部分）**

------

### ② 七层 OSI 模型（对照）

| OSI 七层   | 五层模型对应 | 协议/功能            | 设备                           |
| ---------- | ------------ | -------------------- | ------------------------------ |
| 应用层     | 应用层       | HTTP、FTP、DNS、SMTP | 应用软件                       |
| 表示层     | 应用层       | 编码、加密、压缩     | 软件库                         |
| 会话层     | 应用层       | 建立/维护/管理会话   | 软件库                         |
| 传输层     | 传输层       | TCP、UDP             | 防火墙（**部分**）             |
| 网络层     | 网络层       | IP、ICMP、路由协议   | 路由器、防火墙（**主要功能**） |
| 数据链路层 | 数据链路层   | 以太网、PPP、帧      | 交换机、网桥                   |
| 物理层     | 物理层       | 比特流、物理接口     | 集线器、中继器、网线           |

------

### ③ 总结口诀

- **物理层**：集线器、中继器（传电信号）
- **链路层**：交换机、网桥（管帧转发）
- **网络层**：路由器、防火墙（管IP转发）
- **传输层**：端口防火墙（控制TCP/UDP端口）
- **应用层**：应用协议（HTTP、DNS、邮件等）

👉 口诀：
 **“物理靠电线，链路靠交换，网络靠路由，传输靠端口，应用靠协议。”**

## 结构化

**结构化分析（SA）**：自顶向下逐步分解，侧重功能。

**结构化设计（SD）**：模块化、低耦合高内聚。

**结构化程序设计（SP）**：三种基本控制结构（顺序、选择、循环）

---

## 树与二叉树常考公式速查表

① 树的基本性质

1. 一棵有 $n$ 个结点的树有 **$n-1$ 条边**。

2. 树的度 = 各结点度的最大值。

3. 设 $n_i$ 表示度为 $i$ 的结点数，$n$ 表示总结点数：

   n=n0+n1+n2+⋯+nmn = n_0 + n_1 + n_2 + \dots + n_mn=n0+n1+n2+⋯+nm

------

### ② 叶子结点数公式（树）

设树的度为 $m$，$n_0$ 表示叶子结点数，则：

n0=(n2+2n3+3n4+⋯+(m−1)nm)+1n_0 = (n_2 + 2n_3 + 3n_4 + \dots + (m-1)n_m) + 1n0=(n2+2n3+3n4+⋯+(m−1)nm)+1

**口诀**：叶子数 = (度 ≥ 2 的结点超出部分和) + 1

------

### ③ 二叉树的性质

1. **结点数关系**
    对任意二叉树：

   $n0=n2+1$

   （叶子结点数 = 度为 2 的结点数 + 1）

2. **第 i 层最多结点数**

   ${MaxNodes}(i) = 2^{i-1}$

3. **深度为 k 的二叉树最多结点数**

   ${MaxNodes} = 2^k - 1$

4. **有 n 个结点的完全二叉树深度**

   k=⌊log2^n^⌋+1

5. **满二叉树**

   - 叶子结点数 = 内部结点数 + 1
   - 总结点数 $n = 2n_0 - 1$

------

### ④ 树与二叉树的转换

1. 任意树 → 二叉树：
   - 兄弟相连 → 加横线
   - 只留长子 → 加竖线
   - 删除其他连线
2. 二叉树 → 树：
   - 把左孩子当长子
   - 把右孩子当兄弟

------

### 📖 例题速算

例：一棵二叉树有 20 个叶子结点，问度为 2 的结点有多少个？

- 用公式：$n_0 = n_2 + 1$
- $n_2 = 20 - 1 = 19$ ✅

------

✅ 总结口诀：

- **树：叶子 = 度≥2的超额 + 1**
- **二叉树：叶子 = 度2 + 1**
- **满二叉树：总结点 = 2×叶子 - 1**

### 📖 举个例子

题目里说：一棵树

- 度为 4 的结点：5 个
- 度为 3 的结点：8 个
- 度为 2 的结点：6 个
- 度为 1 的结点：10 个

用公式算：

$n0=(n2+2n3+3n4)+1=(6+2×8+3×5)+1=(6+16+15)+1=38$

结果叶子数 = 38。

------

### ✅ 总结理解

- **度 = 1**：不影响叶子数:  `(1-1)*10 = 0`
- **度 ≥ 2**：多出的 $(k-1)$ 个孩子，会减少 $(k-1)$ 个叶子 → 所以要加进公式
- **最后 +1**：树整体结构补偿

👉 所以口诀才写成：
 **叶子 = （度 ≥ 2 的超额总和） + 1**

