# 图的遍历

## 自学总结

1. 不管图是否有向，得到的深度优先的序列可能是不唯一的 

2. 不管是无向图还是有向图，得到的邻接矩阵都是唯一的，通过邻接矩阵得到的深度优先遍历序列是唯一的

## 有向图

### 有向图的深度遍历



### 有向图的广度遍历

---

## 无向图

### 无向图的深度遍历

### 无向图的广度遍历

---

## 邻接矩阵

### 深度遍历

1. 从第1个节点开始，找到第1行遇到的第一个非0的节点，箭头连接，如1->3
2. 然后从3开始,找第3行的开始遇到的节点，比如遇到的第一个是5,于是得到1->3->5
3. 继续重复上面的操作，从第5行开始找，如果第5行全是0或者第5行遇到的所有非0的节点都被找到过，那么向箭头左边回退，得到3,继续找第3行遇到的未曾找到的节点，比如次时找到了2,于是得到的序列是1->3->5->4
4. 重复上面的序列，直到已找到的序列数目=总节点-1时，把还没找到的那个序列直接放在末尾，就是深度优先遍历的序列

## 广度遍历

这个很简单，

1. 从第1个节点1开始，在第1行遇到了3和5，则得到 1->3->5
2. 1已经找过了，按照上面的序列开始找第3行，假设第3行是2和4,那么得到序列1->3->5->2->4,此时发现序列的长度已经等于所有节点数，那么广度遍历序列遍历完成。
3. 如果3找完之后，发现还有序列没找完，继续从3后面的箭头执行的行开始5找
4. 重复上面的操作。直到所有的节点都被遍历完

---

[ 2020年软件设计师考试上午真题](https://ebook.qicoder.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/notes/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%EF%BC%88%E4%B8%93%E4%B8%9A%E8%A7%A3%E6%9E%90+%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%89.html#%E7%AC%AC-49-%E9%A2%98)

某有向图如下所示，从顶点v1出发对其进行深度优先遍历，可能得到的遍历序列是（**D**）; 从顶点v1出发对其进行广度优先遍历，可能得到的遍历序列是（ **B**）。

![img](https://ebook.qicoder.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/images/shiti/2020-11/411/c62szFGub2.png)

①v1 v2v3 v4 v5

②v1 v3 v4v5v2

③v1 v3v2v4 v5

④v1 v2v4v5 v3

> - (A) ①②③
> - (B) ①③④
> - (C) ①②④
> - (D) ②③④
>
> - (A) ①②
> - (B) ①③
> - (C) ②③
> - (D) ③④

---

[数据结构与算法：基于邻接矩阵的图的深度优先遍历和广度优先遍历](https://www.bilibili.com/video/BV1D64y1K7Xv/?spm_id_from=333.337.search-card.all.click&vd_source=388f01bb44f002e4de4c1a3c6ceb7302)

![image-20250830211249895](../../img/image-20250830211249895.png)

---

![image-20250830211408154](../../img/image-20250830211408154.png)

---

