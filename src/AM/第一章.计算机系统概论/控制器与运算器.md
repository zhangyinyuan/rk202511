# 冯·诺依曼体系

## 核心思想

- 

### 指令和数据不加区别

> 本质上指令也是“数据”，只不过 CPU 会把它解释为操作。
>
> 这就是为什么有些漏洞能“代码注入”，因为机器区分不了“这是程序还是普通数据”

### 顺序执行（控制流模型）

> 程序执行一般按照顺序流动，由 **程序计数器 PC** 自动控制指令的执行顺序

> 整个过程由 **CPU 控制器** 自动完成，而不是人工干预。

- **运算器**（ALU，负责算数逻辑运算）

- **控制器**（负责指令的取/译/执行）
- **存储器**（保存程序和数据）
- **输入设备**（外界数据输入）
- **输出设备**（计算结果输出

## 指令与硬件联系

**指令是规则（What to do）**

**硬件是执行者（How to do）**

---

## 控制器

### 1️⃣ PC（程序计数器）

- **存的是什么？**
   下一条要取的指令的内存地址。
- **怎么用？**
   控制器把 PC 的值送到 **MAR** → 取指令。
- **之后呢？**
  - 指令取出来后，PC 自动 +1 或者根据跳转指令修改，指向下一条。
- **一句话**：未来的“指令地址来源”。

------

### 2️⃣ MAR（主存地址寄存器）

- **存的是什么？**
   当前 CPU 要访问的内存单元**地址**（无论是指令地址还是数据地址）。
- **怎么用？**
   内存根据 MAR 的地址 → 定位 → 把内容送出来。
- **之后呢？**
   数据或指令会放进 **MDR**。
- **一句话**：CPU 和内存交互时的“门牌号”。

------

### 3️⃣ MDR（主存数据寄存器 / 数据缓冲寄存器）

- **存的是什么？**
  - 从内存里取出来的数据（读操作）；
  - 或者 CPU 要写回去的**数据**（写操作）。
- **怎么用？**
  - 取指令时：MDR → IR（指令寄存器）；
  - 取数据时：MDR → 通用寄存器 / ALU；
  - 写数据时：CPU → MDR → 内存。
- **一句话**：数据进出内存的“缓冲区/中转仓”。

------

### 4️⃣ IR（指令寄存器）

- **存的是什么？**
   从 MDR 送过来的 **当前正在执行的指令内容**。
- **怎么用？**
   控制器对 IR 里的指令进行译码，然后驱动 ALU/寄存器/内存操作。
- **之后呢？**
   执行完 → 等下一条指令从 MDR 送过来覆盖。
- **一句话**：正在放映的“当前指令”。

------

## 📌 总结一句话链路（取指周期）

1. **PC → MAR**：下一条指令地址给 MAR。
2. **MAR → 内存**：内存根据地址找到指令内容。
3. **内存 → MDR**：把指令内容送到 MDR。
4. **MDR → IR**：IR 存好，CPU 开始执行。



注意：先访问后执行。访问 **≠** 执行，访问和执行的不是同一个主体
