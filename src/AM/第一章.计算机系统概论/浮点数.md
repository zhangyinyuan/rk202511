# 浮点数
## [浮点数的表示](https://ebook.qicoder.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/notes/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%EF%BC%88%E4%B8%93%E4%B8%9A%E8%A7%A3%E6%9E%90+%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%89.html#%E7%AC%AC-3-%E9%A2%98)：对违规审(舍的谐音)判

### 浮点数运算的过程：对阶→尾数运算→规格化。

### 其中对阶的过程：小数向大数看齐，尾数右移。

---

**具体步骤了解：**

1. **对阶**：
   - 找出两个浮点数中阶码较大的一个，并将较小阶码的浮点数进行调整。
   - 计算两个阶码的差值 ΔE。
   - 将阶码较小的浮点数的尾数向右移动 ΔE 位，同时将阶码加 ΔE，使其与较大阶码的浮点数一致。
   - 隐藏位的 1 需要在尾数移位过程中进行处理。
2. **尾数加减**：在两个数的小数点已经对齐之后，对它们的尾数进行加法或减法运算。在进行尾数加减之前，需要先还原在对阶过程中可能被“隐含”的数位。
3. **规格化**：
   - 进行规格化处理，目的是使尾数的第一个有效数字（也就是小数点左边）始终为1。
   - **右规**：如果尾数的最高位为 01（表示小数部分有前导 0），则将尾数右移一位，同时将阶码加 1。
   - **左规**：如果尾数的符号位不同且计算结果溢出，则将尾数左移一位，同时将阶码减 1。
   - 尾数左移一位会使阶码减小，可能导致指数下溢；尾数右移一位会使阶码增大，可能导致指数上溢。
4. **舍入**：
   - 在对阶和尾数进行右规操作时，由于尾数右移而丢失了部分低位数值。
   - 为了维持精度，需要对移出的低位数值进行舍入处理，常见的有“0舍1入”法等。
5. **溢出判断**：
   - 在完成规格化和舍入后，需要对阶码进行溢出判断。
   - **指数上溢**：如果结果的阶码大于所能表示的最大阶码，则判断为上溢。
   - **指数下溢**：如果结果的阶码小于所能表示的最小阶码（或绝对值小于最小非规格化数），则判断为下溢，结果为零。 
