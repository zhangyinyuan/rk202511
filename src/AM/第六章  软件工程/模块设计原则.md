# 模块设计原则

## 将判定所在模块合并到父模块中，使判定处于较高层次

> 

## 控制范围覆盖影响范围/模块的作用范围应该在控制范围内

> 将受判定影响的模块下移到控制范围内

## 将判定上移到层次较高的位置

---

## ⚠️ 常见陷阱（考试爱考点）

| 错误做法                 | 为什么不行                                  |
| ------------------------ | ------------------------------------------- |
| **把父模块下移**         | 破坏层次结构，逻辑混乱（就像上一题 D 选项） |
| **一个模块管太多事**     | 内聚性差，维护困难                          |
| **判定分散在多个子模块** | 控制分散，导致控制范围覆盖不了作用范围      |
| **模块过细/过粗**        | 过细：层次过多效率低；过粗：耦合度高难维护  |

---

## 代码举例

### ❌ 错误示例：把父模块下移（层次乱掉）

```java
public class OrderSystem {

    // 父模块下移：控制逻辑写在底层（错误做法）
    public void processOrder(String userType, double amount) {
        PaymentModule paymentModule = new PaymentModule();
        paymentModule.pay(userType, amount);
    }
}

class PaymentModule {

    // 这里居然做了“父模块”的控制逻辑 → 把父模块下移了
    public void pay(String userType, double amount) {
        if ("VIP".equals(userType)) {
            System.out.println("VIP 用户，享受 20% 折扣");
            System.out.println("支付金额：" + amount * 0.8);
        } else {
            System.out.println("普通用户，支付金额：" + amount);
        }
    }
}
```

👉 问题：

- `PaymentModule` 本来应该只管“支付”，结果却写了“VIP 判定逻辑”。
- **父模块（业务规则）下移到子模块（支付）**，违反了“控制范围覆盖作用范围”的原则。
- 这样做会导致：后续如果要修改用户类型逻辑，要动支付模块，模块间耦合度大大增加。

### ✅ 正确示例：父模块在上层控制

```java
public class OrderSystem {

    // 父模块负责控制逻辑
    public void processOrder(String userType, double amount) {
        double payAmount = amount;

        if ("VIP".equals(userType)) {
            payAmount = amount * 0.8; // 折扣逻辑
        }

        PaymentModule paymentModule = new PaymentModule();
        paymentModule.pay(payAmount);
    }
}

class PaymentModule {

    // 子模块只管“支付”功能，不掺杂业务判定逻辑
    public void pay(double amount) {
        System.out.println("支付金额：" + amount);
    }
}
```

“把父模块下移”就像老板写代码，没人全局指挥，乱套了。正确做法是：**判定逻辑上移，执行逻辑下放**。

