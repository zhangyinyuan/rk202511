# 白盒测试

## 🧠 白盒测试覆盖率层级

### 1️⃣ 语句覆盖 (Statement Coverage)

- 要求：每条语句至少执行一次。
- 最低层级。
- 例子：

```
if (x > 0) {
    y = 1;
} else {
    y = -1;
}
```

### 2️⃣( 整个表达式)判定覆盖 / 分支覆盖 (Decision/Branch Coverage)

- 要求：每个分支（True/False）至少执行一次。
- 比语句覆盖更严格。
- 上面例子：要测 `x=1` 和 `x=-1`，才能覆盖两个分支。

------

### 3️⃣ (子)条件覆盖 (Condition Coverage)

- 要求：每个**基本条件的真假至少执行一次**。
- 如果条件是 `(A && B)`，就要保证 A 和 B 各自取 True/False。

------

### 4️⃣ 条件/判定覆盖 (Condition/Decision Coverage)

- 同时满足 **条件覆盖** 和 **分支覆盖**。
- 覆盖度更高。

------

### 5️⃣ 路径覆盖 (Path Coverage)

- 要求：覆盖程序中所有可能路径。
- 最严格、代价最大，通常不可完全实现。

📊 层级关系图

```
路径覆盖
   ↑
条件/判定覆盖
   ↑
条件覆盖     判定覆盖
   ↑         ↑
   └───> 语句覆盖
```

👉 实际工程中，常用的组合是 **分支覆盖 + 循环覆盖**，在成本和效果之间平衡。

## **对比总结**

| 维度     | 白盒测试                 | 黑盒测试                     |
| -------- | ------------------------ | ---------------------------- |
| 关注点   | 内部实现逻辑             | 功能与需求                   |
| 视角     | 开发者视角               | 用户视角                     |
| 覆盖目标 | 代码路径、分支           | 输入输出组合、场景           |
| 优势     | 找逻辑缺陷、保证实现正确 | 验证需求、保证功能可用       |
| 劣势     | 成本高、依赖代码         | 覆盖不全面、逻辑漏洞可能漏掉 |
| 应用阶段 | 单元测试、集成测试       | 系统测试、验收测试           |

## 📊 **判定覆盖** VS **条件覆盖 **对比总结

| 类型         | 关注点                | 例子                                         |
| ------------ | --------------------- | -------------------------------------------- |
| **判定覆盖** | 表达式整体 True/False | 覆盖 `(A>0 && B>0)` 为 True 和 False 各一次< |
| **条件覆盖** | 每个子条件 True/False | A、B 都至少取过 True 和 False                |

#### 示例代码

```java
if (A > 0 && B > 0) {
    System.out.println("Condition is TRUE");
} else {
    System.out.println("Condition is FALSE");
}
```

##### 判定覆盖 (Decision / Branch Coverage)

**目标**：**整个表达式**为 True 一次，为 False 一次。

测试用例：

- 用例 1：`A = 1, B = 1` → `(true && true)` = True
- 用例 2：`A = 0, B = 0` → `(false && false)` = False

👉 覆盖了 True / False 分支 ✅
 👉 但 **A = true && B = false**,或者 **A = false && B = true**  的情况从未执行 ❌

##### 条件覆盖 (Condition Coverage)

📌 真值表回顾

| A>0  | B>0  | 整体判定 |
| :--: | :--: | :------: |
|  T   |  T   |    T     |
|  T   |  F   |    F     |
|  F   |  T   |    F     |
|  F   |  F   |    F     |

**目标**：每个子条件至少为 True 一次、False 一次。

测试用例：

- 用例 1：`A = 1, B = 1` → A = true, B = true
- 用例 2：`A = 1, B = 0` → A = true, B = false
- 用例 3：`A = 0, B = 1` → A = false, B = true

👉 覆盖了 A、B 各自的 True/False ✅
 👉 但这里没有保证“整个表达式” True/False 都覆盖到（比如 `(false && false)` 情况没跑）。

## 环路复杂度 V(G) 

路复杂度 V(G) 的数值 直接等于 **覆盖所有独立路径**所需的**最小测试用例数**

## 📌 理由

1. **V(G) 的定义**
   - V(G) 表示 **控制流图中独立路径 (Independent Paths) 的数量**。
2. **独立路径**
   - 独立路径 = 至少包含一条之前路径中没有的新边的路径。
   - 这些路径是构成程序逻辑的“基” (basis paths)，像线性代数里的基底向量。
3. **测试用例和路径覆盖**
   - 如果想要覆盖程序中的所有独立路径，**至少需要 V(G) 条路径**。
   - 每条路径对应至少一个测试用例。



