# 散列表(哈希表)

### 📖 题目

以下关于散列表（哈希表），及其查找特性的叙述中，正确的是（57）。

------

### 📌 选项解析

**A. 在散列表中进行查找时，只需要与待查找关键字及其同义词进行比较**

- ❌ 错误。应该是“与散列到同一地址的关键字比较”，不是“同义词”。

**B. 只要散列表的装填因子不大于 1/2，就能避免冲突**

- ❌ 错误。装填因子小只能降低冲突概率，不能完全避免冲突。

**C. 用线性探测法解决冲突容易产生聚集问题**

- ✅ 正确。线性探测容易产生**一次聚集 (Primary Clustering)**。这是 **线性探测法的主要缺陷**。

**D. 用链地址法解决冲突可确保平均查找长度为 1**

- ❌ 错误。链地址法的平均查找长度大约是 **1+α**，取决于装填因子 α，不可能固定为 1。

---

## 同义词

👉 **不同的关键字经过哈希函数计算后，得到相同的哈希地址**

## 一次聚集

在 **开放定址法（线性探测）** 的哈希表里，如果多个不同的关键字因为冲突而形成了一段 **连续的槽位区间**，就叫做 **一次聚集**。

---

把 **7, 14, 28** 每个关键字的插入过程，逐步拆开分析（用哈希函数 H(key) = key % 7，表长 m=7，冲突处理方式：线性探测）

## 📖 插入过程逐步分析

### 1️⃣ 插入 7

- 计算哈希地址：H(7) = 7 % 7 = 0

- 槽 [0] 空闲 → 存放在槽 [0]

- 表状态：

  ```
  [0]=7, [1]=- , [2]=- , [3]=- , [4]=- , [5]=- , [6]=-
  ```

### 2️⃣ 插入 14

- 计算哈希地址：H(14) = 14 % 7 = 0
- 槽 [0] 已经被 7 占用（冲突发生）
- 按 **线性探测** 向后找：
  - 槽 [1] 空闲 → 存放在槽 [1]
- 表状态：
	```
	[0]=7, [1]=14, [2]=- , [3]=- , [4]=- , [5]=- , [6]=-
	```

### 3️⃣ 插入 28

- 计算哈希地址：H(28) = 28 % 7 = 0
- 槽 [0] 已经被 7 占用（冲突）
- 向后探测：槽 [1] 被 14 占用（继续冲突）
- 向后探测：槽 [2] 空闲 → 存放在槽 [2]
- 表状态：
  ```
  [0]=7, [1]=14, [2]=28, [3]=- , [4]=- , [5]=- , [6]=-
  ```

📊 最终哈希表状态

```
[0] = 7
[1] = 14
[2] = 28
[3] = -
[4] = -
[5] = -
[6] = -
```

## ✅ 总结规律

- 这 4 个关键字 (7, 14, 28) 哈希值都一样（H(key)=0）,**7、14、28这三个关键字互为同义词**。
- 因为都映射到槽 [0]，就形成了 **一次聚集 (Primary Clustering)**：一条连续的探测链 `[0..3]`。

